<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://rohildshah.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://rohildshah.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-11-30T07:44:31+00:00</updated><id>https://rohildshah.github.io/feed.xml</id><title type="html">Rohil Shah</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Survival Guide to CS 292F: Real-Time High Quality Rendering</title><link href="https://rohildshah.github.io/blog/2024/cs-292f-survival-guide/" rel="alternate" type="text/html" title="Survival Guide to CS 292F: Real-Time High Quality Rendering"/><published>2024-08-09T19:33:16+00:00</published><updated>2024-08-09T19:33:16+00:00</updated><id>https://rohildshah.github.io/blog/2024/cs-292f-survival-guide</id><content type="html" xml:base="https://rohildshah.github.io/blog/2024/cs-292f-survival-guide/"><![CDATA[<p>In Spring 2024, I took Professor Lingqi Yan’s offering of <a href="https://sites.cs.ucsb.edu/~lingqi/teaching/cs292f.html">CS 292F: Real-Time High Quality Rendering</a> at UCSB. I came into this class with little to no previous experience in computer graphics. Here’s my “developer diary” that may help you succeed in the class if you are in the same situation.</p> <p>As a brief aside, I consciously chose not to use NanoGUI or similar tools to try and code the projects from “scratch”. This definitely slowed me down, especially by the time I got to the last project, since it would have been useful to see the effect of changing a constant without re-running the process. However, at least at the beginning, I gained a deeper understanding of how the development environment really worked.</p> <hr/> <p><br/></p> <h2 id="project-0-a-real-time-object-viewer">Project 0: A Real-Time Object Viewer</h2> <p>The main task for this project is to set up your development environment. I work on an M1 Macbook Pro and chose VS Code as my IDE. I also arbitrarily chose OpenGL as my graphics interface. Your mileage my vary with this guide if you are using different tools.</p> <p><strong>Note:</strong> <a href="https://www.reddit.com/r/opengl/comments/oc8ec1/opengl_on_mac/">OpenGL is deprecated on MacOS</a>. However, it’s still usable at version 4.1, and it’s unlikely you’ll need the newer features present in versions &gt; 4.1 for this class.</p> <p>This guide on <a href="https://selamjie.medium.com/set-opengl-on-macos-with-vs-code-1a92850c8c6f">setting up OpenGL with MacOS/VS Code</a> proved very useful in getting me started, although I did things slightly differently at various steps.</p> <p>There’s also Learn OpenGL’s <a href="https://learnopengl.com/Getting-started/Creating-a-window">“Creating a window”</a> article that was very useful for a second opinion on various setup tasks.</p> <h3 id="helpful-libraries">Helpful Libraries</h3> <p>Online tutorials, including the ones linked above, often begin with a recommendation to blindly install GLFW, GLUT, GLEW, GLAD, or others. To understand exactly what each is used for, <a href="https://www.reddit.com/r/cpp_questions/comments/ryr3fk/good_explanations_of_differences_between_glfw/">this</a> is a helpful Reddit post. Here’s a brief summary:</p> <ol> <li><strong>GLFW/GLUT:</strong> Provides the essentials to create a window or handle inputs/events. I chose GLFW.</li> <li><strong>GLAD/GLEW:</strong> Provides an interface to access OpenGL API functions. Read <a href="https://arc.net/l/quote/ouglhyqm">this paragraph</a> from Learn OpenGL for more details. I chose GLAD.</li> </ol> <p>GLFW and GLAD are the bare minimum necessary to get your first window and first triangle on your screen.</p> <h3 id="installing-glfw">Installing GLFW</h3> <p>The guides linked above will direct you towards the <a href="https://www.glfw.org/download.html">GLFW official website</a> to download the MacOS pre-compiled binaries. I opted instead to install <a href="https://formulae.brew.sh/formula/glfw">GLFW via Homebrew</a>, after finding this incredibly helpful document on <a href="https://gist.github.com/v3n/27e810ac744b076ceeb7">OpenGL Development for OS X</a>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ brew install glfw
</code></pre></div></div> <h3 id="installing-glad">Installing GLAD</h3> <p>I simply followed the instructions from the first guide <a href="https://arc.net/l/quote/usvejvvf">linked above</a>. As the author mentions, I placed <code class="language-plaintext highlighter-rouge">glad.h</code> under <code class="language-plaintext highlighter-rouge">include/glad/</code> and <code class="language-plaintext highlighter-rouge">glad.c</code> under <code class="language-plaintext highlighter-rouge">src/</code>.</p> <h3 id="setting-up-a-build-system">Setting up a build system</h3> <p>Now comes the task of wrangling these libraries to ensure successful compilation of your C++ code. The guides linked above recommend <a href="https://code.visualstudio.com/docs/editor/tasks">VS Code Tasks</a> or <a href="https://cmake.org/">CMake</a> as build systems. I’m unfamiliar with both, so I opted to keep things simple by using a <a href="https://makefiletutorial.com/">Makefile</a>. Let’s walk through it here:</p> <ol> <li>First, define the C and C++ compilers: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C = clang
CPP = clang++
</code></pre></div> </div> <ul> <li>Since GLAD is a C-based library, it is necessary to first compile the C into an object file using <code class="language-plaintext highlighter-rouge">clang</code>, then include the object file as a source file for <code class="language-plaintext highlighter-rouge">clang++</code>. <br/><br/></li> </ul> </li> <li>Next, define their flags: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C_FLAGS = -Wall -Wno-unused-command-line-argument -c
CPP_FLAGS = -Wall -std=c++11
</code></pre></div> </div> <ul> <li>The <code class="language-plaintext highlighter-rouge">-c</code> flag for <code class="language-plaintext highlighter-rouge">clang</code> will generate an object file, as desired.</li> <li>I arbitrarily chose C++11 for this class. <br/><br/></li> </ul> </li> <li>Define output directories: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>APP_NAME = main
BUILD_DIR = ./bin
</code></pre></div> </div> <ul> <li><code class="language-plaintext highlighter-rouge">./bin</code> is arbitrarily the location for any outputs.Executables will be named <code class="language-plaintext highlighter-rouge">main</code> or <code class="language-plaintext highlighter-rouge">main.o</code> (depending on the stage of compilation). <br/><br/></li> </ul> </li> <li>Define sources for C and C++: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C_SOURCES = ./src/*.c
CPP_SOURCES = ./src/*.cpp
</code></pre></div> </div> </li> <li>Define include file directory (<code class="language-plaintext highlighter-rouge">.h</code> files): <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>APP_INCLUDES = -I./include -framework Cocoa -framework OpenGL -framework IOKit
</code></pre></div> </div> <ul> <li>Since we placed the GLAD header under <code class="language-plaintext highlighter-rouge">include/glad/</code>, we must make sure <code class="language-plaintext highlighter-rouge">clang++</code> can “see” it.</li> <li>I’m unsure on the specifics of the framework arguments, but they seem to be necessary given <a href="https://gist.github.com/v3n/27e810ac744b076ceeb7">this guide</a>. <br/><br/></li> </ul> </li> <li>Define linked libraries: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>APP_LINKERS = -lglfw3
</code></pre></div> </div> <ul> <li>Since we installed GLFW via brew, we don’t need to manually link the <code class="language-plaintext highlighter-rouge">.dylib</code> file or similar. It is automatically found by <code class="language-plaintext highlighter-rouge">clang</code>. <br/><br/></li> </ul> </li> <li>Now the actual build task: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>build:
 $(C) $(C_SOURCES) $(C_FLAGS) -o $(BUILD_DIR)/$(APP_NAME).o $(APP_INCLUDES) $(APP_LINKERS)
 $(CPP) $(BUILD_DIR)/$(APP_NAME).o $(CPP_SOURCES) $(CPP_FLAGS) -o $(BUILD_DIR)/$(APP_NAME) $(APP_INCLUDES) $(APP_LINKERS)
</code></pre></div> </div> <ul> <li>Note the C compilation step will output the object file <code class="language-plaintext highlighter-rouge">bin/main.o</code></li> <li>Then, <code class="language-plaintext highlighter-rouge">bin/main.o</code> is included as one of the sources for the C++ compilation step. <br/><br/></li> </ul> </li> <li>Finally, the run task: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>run: build
 $(BUILD_DIR)/$(APP_NAME)
</code></pre></div> </div> <ul> <li>Note that the run task naturally depends on the build task</li> </ul> </li> </ol> <p>Now, <code class="language-plaintext highlighter-rouge">make build</code> and <code class="language-plaintext highlighter-rouge">make run</code> should correctly compile your C++ code. As I got further with the projects, I found myself needing to add custom classes or new libraries. They fit cleanly into this framework: <code class="language-plaintext highlighter-rouge">.h</code> files can be placed under the <code class="language-plaintext highlighter-rouge">include/</code> directory, and their corresponding <code class="language-plaintext highlighter-rouge">.cpp</code> files can be placed under the <code class="language-plaintext highlighter-rouge">src/</code> directory.</p> <h3 id="actually-completing-the-project">Actually completing the project</h3> <p>Now that our development environment is set up, it’s time to actually do the project. I won’t go into detail about my implementation, but here are some assorted tips:</p> <ol> <li><a href="https://learnopengl.com/Introduction">Learn OpenGL</a> will basically guide you through the whole project, all the way up to the Phong lighting model. Use it!</li> <li>Take Learn OpenGL’s custom camera class and run with it (modify as desired)</li> <li>Same with the Learn OpenGL shader class; it’s very useful to be able to separate your vertex/fragment shaders into another file. Plus, VS Code has extensions for basic <a href="https://marketplace.visualstudio.com/items?itemName=slevesque.shader">syntax highlighting</a> for shader languages.</li> <li>Eventually Learn OpenGL will have you install <a href="https://github.com/g-truc/glm">GLM</a>. Include it in the same way that we did for GLAD.</li> <li>Make your own .OBJ loader class using <a href="https://www.opengl-tutorial.org/beginners-tutorials/tutorial-7-model-loading/">this guide</a> that I found from Prof. Yan’s slides. Understand it and edit to your needs.</li> <li>Find .OBJ files on the internet and use <a href="https://www.meshlab.net/">Meshlab</a> to normalize them to a form that your loader class can handle.</li> </ol> <p><img src="/assets/images/292F/Project 0.png" alt=""/></p> <hr/> <p><br/></p> <h2 id="project-1-percentage-closer-soft-shadows">Project 1: Percentage Closer Soft Shadows</h2> <p>After completing Project 0, there is significantly less setup required to implement PCSS. Here are some assorted tips:</p> <ol> <li>This <a href="https://developer.download.nvidia.com/whitepapers/2008/PCSS_Integration.pdf">NVIDIA PCSS Whitepaper</a> can help with ideas.</li> <li><a href="https://github.com/diharaw/area-light-shadows/tree/master">This</a> project from <a href="https://github.com/diharaw">diharaw</a> suggests using Poisson-disk sampling.</li> <li>I found this PCSS overview from <a href="https://www.gamedev.net/tutorials/programming/graphics/effect-area-light-shadows-part-1-pcss-r4971/">gamedev.net</a> to be informative.</li> </ol> <p><img src="/assets/images/292F/Project 1a.png" alt=""/> <img src="/assets/images/292F/Project 1b.png" alt=""/></p> <hr/> <p><br/></p> <h2 id="project-2-global-illumination-techniques">Project 2: Global Illumination Techniques</h2> <p>Out of RSM, VXGI, SSDO, and SSR, I chose to implement SSDO. I also chose to begin by implementing SSAO, then extending it to SSDO. Here are some assorted tips:</p> <ol> <li>Learn OpenGL has a <a href="https://learnopengl.com/Advanced-Lighting/SSAO">guide for SSAO</a>.</li> <li>You’ll need G-buffers to go from SSAO to SSDO. Here’s the relevant <a href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">Learn OpenGL article</a>. It covers deferred shading, which is not necessary for this project, but deferred shading uses G-buffers, so pick and choose the parts of the article that are relevant.</li> <li>John Chapman’s <a href="https://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html">SSAO tutorial</a> also proved very useful. Again, pick and choose the parts of the tutorial that are relevant. For example, this article gave me the idea to use linear interpolation to bias my samples towards the origin.</li> <li>The Gram-Schmidt process is important for normal-orienting your sample hemisphere. Read about it on Wikipedia <a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process">here</a>.</li> <li>Here’s Tobias Ritschel’s <a href="https://people.mpi-inf.mpg.de/~ritschel/Papers/SSDO.pdf">original SSDO paper</a> for reference.</li> <li>Once I got SSAO working, this <a href="https://ascane.github.io/assets/portfolio/ssdo-report.pdf">SSAO to SSDO report</a> by Chia-Man Hung helped me get my bearings to take on SSDO.</li> </ol> <p><img src="/assets/images/292F/Project 2a.png" alt=""/> <img src="/assets/images/292F/Project 2b.png" alt=""/></p> <hr/> <p><br/></p> <h2 id="project-3-kulla-conty-multiple-bounce-brdf">Project 3: Kulla-Conty Multiple-Bounce BRDF</h2> <p>I chose to skip this project! Since I had become comfortable with my development environment, I didn’t feel like leaving it to implement this project on ShaderToy.</p> <hr/> <p><br/></p> <h2 id="project-4-real-time-ray-tracing">Project 4: Real-Time Ray Tracing</h2> <p>This project proved to be slightly more involved, so I’ll break my tips into sections.</p> <h3 id="generating-noisy-images">Generating Noisy Images</h3> <p>I arbitrarily chose <a href="https://www.blender.org/">Blender</a> for this task since I already had it installed. I had no real experience with using Blender, but it was surprisingly easy to get started, so I would recommend it to other beginners. Some assorted tips:</p> <ol> <li>Find a nice Blender scene with keyframed camera movements already created. This saves you the hassle of learning how to animate camera movement when you’re just getting started. The <a href="https://www.blender.org/download/demo-files/">Blender Demo Files</a> page has a lot of cool scenes to use. I chose the <a href="https://download.blender.org/demo/test/classroom.zip">classroom</a> scene, which happened to have camera animation set up.</li> <li>You’ll be using <a href="https://www.blender.org/features/rendering/">Blender Cycles</a> to render the images. Blender Guru has a <a href="https://www.youtube.com/watch?v=JCLSJg9sdNI">tutorial</a> on what Cycles is and how to use it.</li> <li>In addition to the 1 SPP ray-traced images, you’ll want the G-buffer information via <a href="https://docs.blender.org/manual/en/latest/render/layers/passes.html">Blender’s Render Data Passes</a>.</li> <li>Save all of this data to files using the <a href="https://docs.blender.org/manual/en/latest/compositing/index.html">Blender compositor</a>. Here’s a <a href="https://blender.stackexchange.com/questions/28740/how-can-i-render-all-render-passes-to-files-in-cycles">forum article</a> on doing that.</li> <li>I chose to save the data to PNGs, but you can save it to whatever format you like. The next section will explain why PNGs are useful when loading the data to the GPU.</li> <li>The compositor is also where you can modify your data to fit the strict RGB [0, 1] requirements of PNGs. For example, world position and motion vectors will have some negative values, which need to be mapped to [0, 1] as you see fit.</li> </ol> <h3 id="loading-the-images-to-the-gpu">Loading the images to the GPU</h3> <p>Once you have the images, you’ll now have to load them as textures to the GPU. Here’s some assorted tips on doing that:</p> <ol> <li>This <a href="https://learnopengl.com/Getting-started/Textures">Learn OpenGL article on Textures</a> is helpful for figuring out how to load various file formats into an OpenGL texture that can be sent to the GPU.</li> <li>The article will recommend using the <a href="https://github.com/nothings/stb/blob/master/stb_image.h">STB Image Header File</a>, which I will also highly recommend. It supports 8- and 16-bit PNGs, which is exactly the flexibility I needed.</li> <li>Load all the data before your main render loop, rather than within the loop itself. I made this mistake and it tanked my FPS since you would have to fetch a couple megabytes from disk every single frame.</li> </ol> <h3 id="denoising-techniques">Denoising Techniques</h3> <p>My final implementation included a joint bilateral filter, temporal accumulation, and temporal clamping to reduce disocclusion. I found it unnecessary to do outlier clamping for fireflies and to implement optimizations like horizontal/vertical blur pass or a-trous wavelet sampling since I got &gt;30 FPS even for a large 33x33 kernel. Here are some more tips:</p> <ol> <li>To implement temporal accumulation, simply write the default framebuffer’s default color attachment (output texture) to another texture within the main loop using <code class="language-plaintext highlighter-rouge">glCopyTexSubImage2D</code>. This gave me a headache for a while before I realized you don’t need any other framebuffers other than the default one, along with some free-floating textures.</li> <li>Get out a pencil and paper to work out the correct conversions for the motion vectors and world position so that you don’t dig yourself into a hole with silly mistakes and spend hours digging yourself out (like I did).</li> <li>When accumulating the weighted color from every sample around a pixel, divide out the albedo of sample. Then, multiply the pixel’s albedo to the result of the weighted average to compensate for the loss. This stops the albedo component from being blurred and will lead to much cleaner results.</li> </ol> <p><img src="/assets/images/292F/Project 4a.png" alt=""/> <img src="/assets/images/292F/Project 4b.png" alt=""/></p> <hr/> <p><br/></p> <h2 id="final-thoughts">Final thoughts</h2> <p>Regardless of your level of experience with computer graphics, you can succeed in this class! It’ll take some time and self-teaching, but as long as you don’t lose interest, you’ll do well. Remember to have fun and mess around with your code while working on the projects; it’s the best way to learn. I could fill a library with the wacky visual effects I’ve made by messing up my implementations.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[In Spring 2024, I took Professor Lingqi Yan’s offering of CS 292F: Real-Time High Quality Rendering at UCSB. I came into this class with little to no previous experience in computer graphics. Here’s my “developer diary” that may help you succeed in the class if you are in the same situation.]]></summary></entry></feed>